//! # Query Operations and Response Types
//!
//! This module provides the core functionality for querying the Malware Bazaar API.
//! It includes query operation types, response structures, and functions to execute queries.
//!
//! ## Query Operations
//!
//! The [`QueryOperation`] enum represents different types of queries that can be performed:
//! - Hash-based lookups (SHA256, MD5, SHA1, SHA384)
//! - Certificate-based lookups (issuer CN, subject CN, serial number)
//! - Metadata searches (tags, signatures, file types, etc.)
//! - Recent additions retrieval
//!
//! ## Response Structures
//!
//! The main response type is [`MalwareInformation`], which contains comprehensive details about
//! a malware sample including hashes, file metadata, vendor intelligence, and YARA rules.
//!
//! For certificate blocklist operations, use [`CertBlocklist`] to retrieve revoked certificates.

extern crate serde_json;

use crate::{error, WebFetch};
use serde::Deserialize;

/// A type alias for query results.
///
/// All query operations return this type, where `T` is the result data type
/// and [`error::Error`] represents potential failures.
pub type QueryResult<T> = Result<T, error::Error>;

/// The base URL for the Malware Bazaar API v1 endpoint.
const MALWARE_BAZAAR_API: &str = "https://mb-api.abuse.ch/api/v1/";

/// Comprehensive information about a malware sample from the Malware Bazaar.
///
/// This struct represents the full response from querying malware sample information.
/// It contains file hashes, metadata, detection signatures, and vendor intelligence from
/// multiple security vendors.
#[derive(Debug, Deserialize)]
pub struct MalwareInformation {
    /// SHA256 hash of the malware sample.
    #[serde(rename = "sha256_hash", default)]
    pub sha256_hash: Option<String>,

    /// SHA384 (SHA3-384) hash of the malware sample.
    #[serde(rename = "sha3_384_hash", default)]
    pub sha384_hash: Option<String>,

    /// SHA1 hash of the malware sample.
    #[serde(rename = "sha1_hash", default)]
    pub sha1_hash: Option<String>,

    /// MD5 hash of the malware sample.
    #[serde(rename = "md5_hash", default)]
    pub md5_hash: Option<String>,

    /// Timestamp of when the sample was first seen in the database (ISO 8601 format).
    #[serde(rename = "first_seen", default)]
    pub first_seen: Option<String>,

    /// Timestamp of when the sample was last seen in the database (ISO 8601 format).
    #[serde(rename = "last_seen", default)]
    pub last_seen: Option<String>,

    /// Original file name of the malware sample.
    #[serde(rename = "file_name", default)]
    pub file_name: Option<String>,

    /// Size of the file in bytes.
    #[serde(rename = "file_size", default)]
    pub file_size: i64,

    /// MIME type of the file (e.g., "application/x-dosexec").
    #[serde(rename = "file_type_mime", default)]
    pub file_type_mime: Option<String>,

    /// Human-readable file type classification (e.g., "ELF", "PE32").
    #[serde(rename = "file_type", default)]
    pub file_type: Option<String>,

    /// Name or identifier of the user/organization that reported the sample.
    #[serde(rename = "reporter", default)]
    pub reporter: Option<String>,

    /// ISO 3166-1 country code of the sample's origin, or additional contextual data.
    #[serde(rename = "origin_country", default)]
    pub origin_country: Option<serde_json::Value>,

    /// Boolean flag (0 or 1) indicating if the reporter submitted anonymously.
    #[serde(rename = "anonymous", default)]
    pub anonymous: i64,

    /// Code signing certificate signature or malware family signature name.
    #[serde(rename = "signature", default)]
    pub signature: Option<String>,

    /// Import hash (imphash) of the PE executable, used for similarity matching.
    #[serde(rename = "imphash", default)]
    pub imphash: Option<String>,

    /// Trend Micro TLSH (Trending Locally Sensitive Hash) for fuzzy matching.
    #[serde(rename = "tlsh", default)]
    pub tlsh: Option<String>,

    /// Telfhash (Telemetry Hash) for binary similarity analysis.
    #[serde(rename = "telfhash", default)]
    pub telfhash: Option<String>,

    /// Gimphash (graphical impact-based hash) for icon/image similarity.
    #[serde(rename = "gimphash", default)]
    pub gimphash: Option<String>,

    /// SSDEEP fuzzy hash for structural similarity matching.
    #[serde(rename = "ssdeep", default)]
    pub ssdeep: Option<String>,

    /// Perceptual hash of the file's icon (for PE executables).
    #[serde(rename = "dhash_icon", default)]
    pub dhash_icon: Option<String>,

    /// User-supplied comment or annotation about the sample.
    #[serde(rename = "comment", default)]
    pub comment: Option<String>,

    /// Password for encrypted archives, if the sample is an archive file.
    #[serde(rename = "archive_pw", default)]
    pub archive_pw: Option<serde_json::Value>,

    /// List of tags associated with the sample (e.g., "banker", "ransomware", "trojan").
    #[serde(rename = "tags", default)]
    pub tags: Option<Vec<String>>,

    /// Code signing certificate information for signed executables.
    #[serde(rename = "code_sign", default)]
    pub code_sign: Option<serde_json::Value>,

    /// Method by which the malware was distributed or delivered (e.g., "email", "web").
    #[serde(rename = "delivery_method", default)]
    pub delivery_method: Option<String>,

    /// Intelligence data from various security tools and services.
    #[serde(rename = "intelligence", default)]
    pub intelligence: Option<Intelligence>,

    /// Additional technical information extracted from the file.
    #[serde(rename = "file_information", default)]
    pub file_information: Vec<FileInformation>,

    /// Object Linking and Embedding (OLE) structure information for Office documents.
    #[serde(rename = "ole_information", default)]
    pub ole_information: Vec<Option<serde_json::Value>>,

    /// YARA rules that match this malware sample.
    #[serde(rename = "yara_rules", default)]
    pub yara_rules: Option<serde_json::Value>,

    /// Intelligence data from multiple security vendors.
    #[serde(rename = "vendor_intel", default)]
    pub vendor_intel: Option<VendorIntel>,

    /// Additional comments or notes about the sample.
    #[serde(rename = "comments", default)]
    pub comments: Option<serde_json::Value>,
}

/// Additional technical information extracted from a malware sample.
///
/// Provides contextual metadata about the file, such as compile timestamps,
/// resource information, or other binary properties.
#[derive(Debug, Default, Deserialize)]
pub struct FileInformation {
    /// The type or context of the information (e.g., "CompileTime", "ExportTable").
    #[serde(rename = "context", default)]
    pub context: Option<String>,

    /// The actual value or data associated with the context.
    #[serde(rename = "value", default)]
    pub value: Option<String>,
}

/// Intelligence data from various security tools and services.
///
/// Aggregates detection and behavioral information from ClamAV antivirus,
/// network telemetry (downloads/uploads), and email-based threats.
#[derive(Debug, Default, Deserialize)]
pub struct Intelligence {
    /// List of ClamAV antivirus signatures that detect this sample.
    #[serde(rename = "clamav", default)]
    pub clamav: Option<Vec<String>>,

    /// Number of times this sample was downloaded or encountered in the wild.
    #[serde(rename = "downloads", default)]
    pub downloads: Option<String>,

    /// Number of times this sample was uploaded to sandboxes or analysis services.
    #[serde(rename = "uploads", default)]
    pub uploads: Option<String>,

    /// Information about email-based distribution or payload delivery.
    #[serde(rename = "mail", default)]
    pub mail: Option<String>,
}

/// Intelligence data aggregated from multiple security vendors.
///
/// Provides threat intelligence from various third-party services including
/// sandbox services (CAPE, Triage), threat intelligence platforms (ReversingLabs),
/// and specialized analysis tools (UnpacMe).
#[derive(Debug, Default, Deserialize)]
pub struct VendorIntel {
    /// Detections from CERT.PL Malware Database (CERT-PL MWDB).
    #[serde(rename = "CERT-PL_MWDB")]
    pub cert_pl_mwdb: Option<Cape>,

    /// Detections from Yoroi Yomi threat intelligence service.
    #[serde(rename = "YOROI_YOMI")]
    pub yoroi_yomi: Option<YoroiYomi>,

    /// Verdicts and behavior analysis from vxCube malware analysis platform.
    #[serde(rename = "vxCube")]
    pub vx_cube: Option<VxCube>,

    /// Detections from Cybersecurity and Advanced Proactive Engine (CAPE) sandbox.
    #[serde(rename = "CAPE")]
    pub cape: Option<Cape>,

    /// Malware analysis and family classification from Triage sandbox.
    #[serde(rename = "Triage")]
    pub triage: Option<Triage>,

    /// Threat information from ReversingLabs threat intelligence service.
    #[serde(rename = "ReversingLabs")]
    pub reversing_labs: Option<ReversingLabs>,

    /// Spamhaus High-Confidence Blocklist (HBL) entries if sample is listed.
    #[serde(rename = "Spamhaus_HBL")]
    pub spamhaus_hbl: Option<Vec<Cape>>,

    /// Unpacking results from UnpacMe automated unpacking service.
    #[serde(rename = "UnpacMe")]
    pub unpac_me: Option<Vec<UnpacMe>>,
}

/// Detection and link information from a sandbox or analysis service.
///
/// A generic structure used by multiple vendors (CAPE, CERT-PL MWDB, Spamhaus HBL)
/// to provide detection results and reference links.
#[derive(Debug, Default, Deserialize)]
pub struct Cape {
    /// Detection result or verdict (e.g., "malware detected", "trojan").
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    /// URL link to the detailed analysis report on the vendor's platform.
    #[serde(rename = "link")]
    pub link: Option<String>,
}

/// Threat intelligence from ReversingLabs reputation service.
///
/// Provides threat classifications, detection statistics, and first-seen information
/// from the ReversingLabs threat intelligence database.
#[derive(Debug, Default, Deserialize)]
pub struct ReversingLabs {
    /// The classified threat name or malware family (e.g., "Trojan.Generic").
    #[serde(rename = "threat_name")]
    pub threat_name: Option<String>,

    /// Status of the threat (e.g., "malware", "suspicious", "unknown").
    #[serde(rename = "status")]
    pub status: Option<String>,

    /// Timestamp of when ReversingLabs first saw this threat (ISO 8601 format).
    #[serde(rename = "first_seen")]
    pub first_seen: Option<String>,

    /// Total number of antivirus scanners in ReversingLabs' network.
    #[serde(rename = "scanner_count")]
    pub scanner_count: Option<String>,

    /// Number of scanners that detected this sample as malicious.
    #[serde(rename = "scanner_match")]
    pub scanner_match: Option<String>,

    /// Percentage of scanners that detected this sample as malicious.
    #[serde(rename = "scanner_percent")]
    pub scanner_percent: Option<String>,
}

/// Malware analysis results from the Triage sandbox.
///
/// Comprehensive analysis including malware family classification, behavioral signatures,
/// and extracted configuration data from sandboxed execution.
#[derive(Debug, Default, Deserialize)]
pub struct Triage {
    /// Classified malware family or variant name.
    #[serde(rename = "malware_family")]
    pub malware_family: Option<String>,

    /// Analysis score or severity rating (typically 0-100).
    #[serde(rename = "score")]
    pub score: Option<String>,

    /// URL link to the detailed analysis report on Triage platform.
    #[serde(rename = "link")]
    pub link: Option<String>,

    /// List of behavioral or classification tags assigned by Triage.
    #[serde(rename = "tags")]
    pub tags: Option<Vec<String>>,

    /// YARA or other behavioral signatures detected during analysis.
    #[serde(rename = "signatures")]
    pub signatures: Option<Vec<Signature>>,

    /// Extracted malware configuration data (C2 servers, keys, etc.).
    #[serde(rename = "malware_config")]
    pub malware_config: Option<Vec<MalwareConfig>>,
}

/// Extracted configuration data from malware analysis.
///
/// Contains command-and-control servers, family information, and other
/// configuration details recovered from static or dynamic analysis.
#[derive(Debug, Default, Deserialize)]
pub struct MalwareConfig {
    /// Extraction method or source (e.g., "static", "dynamic", "manual").
    #[serde(rename = "extraction")]
    pub extraction: Option<String>,

    /// Malware family or variant identifier associated with this config.
    #[serde(rename = "family")]
    pub family: Option<String>,

    /// Command-and-Control (C2) server address or list of C2 servers.
    #[serde(rename = "c2")]
    pub c2: Option<String>,
}

/// A behavioral signature or detection rule matched by analysis.
///
/// Represents a single signature or behavioral indicator detected during
/// malware analysis, potentially with an associated severity score.
#[derive(Debug, Default, Deserialize)]
pub struct Signature {
    /// The name or description of the matched signature or behavioral indicator.
    #[serde(rename = "signature")]
    pub signature: Option<String>,

    /// Severity or confidence score for the signature (typically 0-100).
    #[serde(rename = "score")]
    pub score: Option<String>,
}

/// Results from automated unpacking analysis by UnpacMe service.
///
/// Contains hashes of unpacked samples and detection information for payloads
/// extracted from packed or obfuscated executables.
#[derive(Debug, Default, Deserialize)]
pub struct UnpacMe {
    /// SHA256 hash of the unpacked/extracted payload.
    #[serde(rename = "sha256_hash")]
    pub sha256_hash: Option<String>,

    /// MD5 hash of the unpacked/extracted payload.
    #[serde(rename = "md5_hash")]
    pub md5_hash: Option<String>,

    /// SHA1 hash of the unpacked/extracted payload.
    #[serde(rename = "sha1_hash")]
    pub sha1_hash: Option<String>,

    /// List of antivirus detections for the unpacked payload.
    #[serde(rename = "detections")]
    pub detections: Option<Vec<String>>,

    /// URL link to the analysis report on the UnpacMe platform.
    #[serde(rename = "link")]
    pub link: Option<String>,
}

/// Threat analysis results from the vxCube malware analysis platform.
///
/// Provides behavioral verdicts, maliciousness scores, and detected behaviors
/// from sandboxed execution and static analysis.
#[derive(Debug, Default, Deserialize)]
pub struct VxCube {
    /// Verdict or classification (e.g., "malware", "suspicious", "benign").
    #[serde(rename = "verdict")]
    pub verdict: Option<String>,

    /// Maliciousness score or rating indicating threat severity.
    #[serde(rename = "maliciousness")]
    pub maliciousness: Option<String>,

    /// List of detected behaviors or behavioral indicators.
    #[serde(rename = "behaviour")]
    pub behaviour: Option<Vec<Behaviour>>,
}

/// A detected behavioral indicator or threat rule.
///
/// Represents a specific behavior or detection rule triggered during analysis
/// with an associated threat level classification.
#[derive(Debug, Default, Deserialize)]
pub struct Behaviour {
    /// The threat level classification for this behavior.
    #[serde(rename = "threat_level")]
    pub threat_level: Option<ThreatLevel>,

    /// The name or description of the behavioral rule that was triggered.
    #[serde(rename = "rule")]
    pub rule: Option<String>,
}

/// Detection results from the Yoroi Yomi threat intelligence service.
///
/// Provides detection verdicts and associated confidence scores from
/// the Yoroi Yomi malware analysis and threat intelligence platform.
#[derive(Debug, Default, Deserialize)]
pub struct YoroiYomi {
    /// Detection result or verdict from Yoroi Yomi analysis.
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    /// Confidence or severity score for the detection.
    #[serde(rename = "score")]
    pub score: Option<String>,
}

/// Threat level classification for behavioral indicators.
///
/// Represents the severity or confidence level of a detected behavior or threat indicator.
#[derive(Debug, Deserialize)]
pub enum ThreatLevel {
    /// No threat detected; behavior is benign.
    #[serde(rename = "neutral")]
    Neutral,

    /// Behavior is potentially suspicious or concerning.
    #[serde(rename = "suspicious")]
    Suspicious,
}

/// Result limit for queries that return multiple matches.
///
/// Used to control the maximum number of results returned by queries like
/// tag searches, file type searches, and other multi-result operations.
/// The maximum allowed limit is 1000.
pub enum QueryLimit {
    /// Use the default limit of 50 results.
    Default,

    /// Specify a custom limit (must be less than or equal to 1000).
    Limit(i32),
}

/// Conversion of [`QueryLimit`] to an i32 limit value.
///
/// Validates that custom limits do not exceed the maximum of 1000 and
/// returns the default limit of 50 for [`QueryLimit::Default`].
impl TryInto<i32> for QueryLimit {
    type Error = error::Error;

    fn try_into(self) -> Result<i32, Self::Error> {
        match self {
            Self::Limit(limit) if limit > 1000 => Err(error::Error::InvalidValue(format!(
                "Limit should be less than 1000. Specified limit {}",
                limit
            ))),
            Self::Limit(limit) => Ok(limit),
            Self::Default => Ok(50),
        }
    }
}

/// Selector for retrieving recent malware additions.
///
/// Determines how to retrieve the most recently added malware samples:
/// either by time period or by number of latest additions.
pub enum RecentAdditionsSelector {
    /// Retrieve recent additions within a specified time period (e.g., last 24 hours).
    Time,

    /// Retrieve a specific number of the latest additions to the database.
    Latest(i32),
}

/// Converts a [`RecentAdditionsSelector`] into its API parameter string.
///
/// Transforms the selector variant into the appropriate query parameter value.
impl From<RecentAdditionsSelector> for String {
    fn from(value: RecentAdditionsSelector) -> Self {
        match value {
            RecentAdditionsSelector::Time => String::from("time"),
            RecentAdditionsSelector::Latest(latest) => latest.to_string(),
        }
    }
}

/// Internal structure for building query parameters.
///
/// Used to construct the HashMap of query parameters that will be sent to the API.
/// This is an internal type not exposed in the public API.
struct QueryParams<'a> {
    /// The API operation/query type (e.g., "get_info", "get_taginfo").
    operation: &'a str,

    /// The parameter name for the query value (e.g., "hash", "tag").
    key: Option<&'a str>,

    /// The actual value to query for (e.g., hash value, tag name).
    value: Option<String>,

    /// Optional result limit for multi-result queries.
    limit: Option<QueryLimit>,
}

/// Conversion of [`QueryParams`] into a HashMap for API requests.
///
/// Builds the final query parameter map including the operation, optional key-value pair,
/// and optional limit, handling validation of the limit value.
impl<'a> TryInto<std::collections::HashMap<&'a str, String>> for QueryParams<'a> {
    type Error = error::Error;

    fn try_into(self) -> Result<std::collections::HashMap<&'a str, String>, Self::Error> {
        let mut query_params =
            std::collections::HashMap::from([("query", self.operation.to_string())]);

        if let (Some(query_key), Some(query_value)) = (self.key, self.value) {
            query_params.insert(query_key, query_value);
        }

        if let Some(limit) = self.limit {
            query_params.insert(
                "limit",
                <QueryLimit as TryInto<i32>>::try_into(limit)?.to_string(),
            );
        }

        Ok(query_params)
    }
}

/// Query operations available in the Malware Bazaar API.
///
/// Represents the different types of queries that can be performed, including
/// hash-based lookups, certificate searches, and metadata queries.
pub enum QueryOperation {
    /// Query by file hash (SHA256, MD5, SHA1, or SHA384).
    Hash(String),

    /// Query by certificate issuer common name (CN).
    CertIssuerCN(String),

    /// Query by certificate subject common name (CN).
    CertSubjectCN(String),

    /// Query by certificate serial number.
    CertSerialNumber(String),

    /// Retrieve recent malware additions using the specified selector.
    RecentAdditions(RecentAdditionsSelector),

    /// Query samples by a specific tag with optional result limit.
    Tag(String, QueryLimit),

    /// Query samples by a signature name with optional result limit.
    Signature(String, QueryLimit),

    /// Query samples by file type with optional result limit.
    FileType(String, QueryLimit),

    /// Query samples by ClamAV antivirus signature with optional result limit.
    ClamavSignature(String, QueryLimit),

    /// Query samples by import hash (imphash) with optional result limit.
    Imphash(String, QueryLimit),

    /// Query samples by TLSH (Trending Locally Sensitive Hash) with optional result limit.
    TLSH(String, QueryLimit),

    /// Query samples by Telfhash (Telemetry Hash) with optional result limit.
    Telfhash(String, QueryLimit),

    /// Query samples by Gimphash (icon hash) with optional result limit.
    Gimphash(String, QueryLimit),

    /// Query samples by icon DHASH (perceptual icon hash) with optional result limit.
    IconDhash(String, QueryLimit),

    /// Query samples by YARA rule matches with optional result limit.
    YaraInfo(String, QueryLimit),
}

/// Conversion of [`QueryOperation`] into a HashMap for API requests.
///
/// Transforms query operation variants into the appropriate API parameters,
/// including operation names, parameter keys/values, and optional limits.
impl TryInto<std::collections::HashMap<&str, String>> for QueryOperation {
    type Error = error::Error;

    fn try_into(self) -> Result<std::collections::HashMap<&'static str, String>, Self::Error> {
        let query_params = match self {
            Self::Tag(query_value, limit) => QueryParams {
                operation: "get_taginfo",
                key: Some("tag"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Signature(query_value, limit) => QueryParams {
                operation: "get_siginfo",
                key: Some("signature"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::FileType(query_value, limit) => QueryParams {
                operation: "get_file_type",
                key: Some("file_type"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::ClamavSignature(query_value, limit) => QueryParams {
                operation: "get_clamavinfo",
                key: Some("clamav"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Imphash(query_value, limit) => QueryParams {
                operation: "get_imphash",
                key: Some("imphash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::TLSH(query_value, limit) => QueryParams {
                operation: "get_tlsh",
                key: Some("tlsh"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Telfhash(query_value, limit) => QueryParams {
                operation: "get_telfhash",
                key: Some("telfhash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Gimphash(query_value, limit) => QueryParams {
                operation: "get_gimphash",
                key: Some("gimphash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::IconDhash(query_value, limit) => QueryParams {
                operation: "get_dhash_icon",
                key: Some("dhash_icon"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::YaraInfo(query_value, limit) => QueryParams {
                operation: "get_yarainfo",
                key: Some("yara_rule"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Hash(hash) => QueryParams {
                operation: "get_info",
                key: Some("hash"),
                value: Some(hash),
                limit: None,
            },
            Self::CertIssuerCN(issuer_cn) => QueryParams {
                operation: "get_issuerinfo",
                key: Some("issuer_cn"),
                value: Some(issuer_cn),
                limit: None,
            },
            Self::CertSubjectCN(subject_cn) => QueryParams {
                operation: "get_subjectinfo",
                key: Some("subject_cn"),
                value: Some(subject_cn),
                limit: None,
            },
            Self::CertSerialNumber(serial_number) => QueryParams {
                operation: "get_certificate",
                key: Some("serial_number"),
                value: Some(serial_number),
                limit: None,
            },
            Self::RecentAdditions(recent_addition) => QueryParams {
                operation: "get_recent",
                key: Some("selector"),
                value: Some(recent_addition.into()),
                limit: None,
            },
        };

        query_params.try_into()
    }
}

/// A certificate entry from the Malware Bazaar Code Signing Certificate Blocklist.
///
/// Represents a revoked or malicious code signing certificate that has been
/// used to sign malware or is otherwise considered unsafe.
#[derive(Debug, Deserialize)]
pub struct CertBlocklist {
    /// Timestamp when this certificate was added to the blocklist (ISO 8601 format).
    #[serde(rename = "time_stamp")]
    pub time_stamp: String,

    /// X.509 certificate serial number (unique identifier).
    #[serde(rename = "serial_number")]
    pub serial_number: String,

    /// Certificate thumbprint (fingerprint) hash value.
    #[serde(rename = "thumbprint")]
    pub thumbprint: String,

    /// Hash algorithm used for the thumbprint (e.g., "sha1", "sha256").
    #[serde(rename = "thumbprint_algorithm")]
    pub thumbprint_algorithm: String,

    /// Subject Common Name (CN) from the certificate.
    #[serde(rename = "subject_cn")]
    pub subject_cn: String,

    /// Issuer Common Name (CN) from the certificate.
    #[serde(rename = "issuer_cn")]
    pub issuer_cn: String,

    /// Certificate validity start date (ISO 8601 format).
    #[serde(rename = "valid_from")]
    pub valid_from: String,

    /// Certificate validity end date (ISO 8601 format).
    #[serde(rename = "valid_to")]
    pub valid_to: String,

    /// Flag indicating if this certificate is listed in the Code Signing Certificate Blocklist.
    #[serde(rename = "cscb_listed")]
    pub cscb_listed: bool,

    /// Reason for adding the certificate to the blocklist (e.g., "malware signing", "revoked").
    #[serde(rename = "cscb_reason")]
    pub cscb_reason: String,
}

/// Generic API response wrapper for Malware Bazaar queries.
///
/// Wraps the actual query results with status information. If the query succeeded,
/// the `data` field contains the results; otherwise, it is `None` and `query_status`
/// contains an error description.
#[derive(Debug, Deserialize)]
pub struct QueryResponse<T> {
    /// Status of the query execution (e.g., "ok", "error_invalid_query").
    #[serde(rename = "query_status")]
    query_status: String,

    /// Optional list of results matching the query criteria.
    #[serde(rename = "data")]
    data: Option<Vec<T>>,
}

/// Queries the Malware Bazaar API for malware samples.
///
/// Executes a query operation and returns a list of matching malware samples
/// with comprehensive information including hashes, metadata, and vendor intelligence.
///
/// # Arguments
///
/// * `web_client` - An implementation of [`WebFetch`] for making HTTP requests
/// * `query_op` - The specific query operation to perform
///
/// # Returns
///
/// Returns a vector of [`MalwareInformation`] structs on success, or an
/// [`error::Error`] on failure (network error, invalid query, no results, etc.).
///
/// # Errors
///
/// This function returns an error if:
/// - The web request fails (network issues, connection timeout)
/// - The API returns an error status
/// - The response cannot be parsed as JSON
/// - The query parameters are invalid
///
/// # Example
///
/// ```ignore
/// use malware_bazaar_api::{HttpReqwest, WebFetch, queries::{QueryOperation, query_malware_samples}};
///
/// let client = HttpReqwest::default();
/// let query = QueryOperation::Hash("hash_value".to_string());
/// let results = query_malware_samples(&client, query)?;
/// ```
pub fn query_malware_samples(
    web_client: &impl WebFetch,
    query_op: QueryOperation,
) -> QueryResult<Vec<MalwareInformation>> {
    let response = web_client.fetch(MALWARE_BAZAAR_API, query_op.try_into()?)?;
    let response: QueryResponse<MalwareInformation> = serde_json::from_str(&response)?;

    if let Some(response) = response.data {
        Ok(response)
    } else {
        Err(error::Error::QueryError(response.query_status))
    }
}

/// Queries the Malware Bazaar Code Signing Certificate Blocklist.
///
/// Retrieves the complete blocklist of revoked and malicious code signing certificates
/// that have been used to sign malware or are otherwise dangerous.
///
/// # Arguments
///
/// * `web_client` - An implementation of [`WebFetch`] for making HTTP requests
///
/// # Returns
///
/// Returns a vector of [`CertBlocklist`] entries on success, or an [`error::Error`]
/// on failure.
///
/// # Errors
///
/// This function returns an error if:
/// - The web request fails (network issues, connection timeout)
/// - The API returns an error status
/// - The response cannot be parsed as JSON
///
/// # Example
///
/// ```ignore
/// use malware_bazaar_api::{HttpReqwest, queries::query_code_signing_block_list};
///
/// let client = HttpReqwest::default();
/// let blocklist = query_code_signing_block_list(&client)?;
/// for cert in blocklist {
///     println!("Blocked certificate: {}", cert.subject_cn);
/// }
/// ```
pub fn query_code_signing_block_list(
    web_client: &impl WebFetch,
) -> QueryResult<Vec<CertBlocklist>> {
    let response = web_client.fetch(
        MALWARE_BAZAAR_API,
        std::collections::HashMap::from([("query", String::from("get_cscb"))]),
    )?;
    let response: QueryResponse<CertBlocklist> = serde_json::from_str(&response)?;

    if let Some(response) = response.data {
        Ok(response)
    } else {
        Err(error::Error::QueryError(response.query_status))
    }
}

#[cfg(test)]
mod tests {

    use crate::fakers::FakeHttpReqwest;

    use super::*;

    const ILLEGAL_HASH_JSON: &str = "{
        \"query_status\": \"illegal_hash\"
    }";

    const HASH_NOT_FOUND_JSON: &str = "{
        \"query_status\": \"hash_not_found\"
    }";

    const NO_HASH_PROVIDED_JSON: &str = "{
        \"query_status\": \"no_hash_provided\"
    }";

    #[test]
    fn test_query_results() {
        let fake_client = FakeHttpReqwest::default()
            .set_success_response(include_str!("test_files/malware_sample_resp.json").to_string());

        let query_results = query_malware_samples(
            &fake_client,
            QueryOperation::Tag(String::from("deadbeef"), QueryLimit::Default),
        );

        assert!(
            !query_results.unwrap().is_empty(),
            "Malware information cannot be empty"
        );

        let fake_client = fake_client
            .set_success_response(include_str!("test_files/cscb_response.json").to_string());

        let query_results = query_code_signing_block_list(&fake_client);

        assert!(
            !query_results.unwrap().is_empty(),
            "Malware Bazaar certificate list cannot be empty"
        );
    }

    #[test]
    fn test_return_error_when_hash_is_not_valid() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(ILLEGAL_HASH_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_no_hash_was_provided() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(NO_HASH_PROVIDED_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_hash_was_not_found() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(HASH_NOT_FOUND_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_on_request_error() {
        let fake_client = FakeHttpReqwest::default()
            .set_error_response(error::Error::Request(String::from("Request error")));
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::Request(_)));
    }

    #[test]
    fn test_return_error_on_limit_greater_than_1000() {
        let fake_client = FakeHttpReqwest::default();

        let result = query_malware_samples(
            &fake_client,
            QueryOperation::FileType(String::from("deadbeef"), QueryLimit::Limit(1001)),
        )
        .unwrap_err();

        assert!(matches!(result, error::Error::InvalidValue(_)))
    }
}
