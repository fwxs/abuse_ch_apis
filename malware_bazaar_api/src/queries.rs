extern crate serde_json;

use crate::{error, WebFetch};
use serde::Deserialize;

pub type QueryResult<T> = Result<T, error::Error>;

const MALWARE_BAZAAR_API: &str = "https://mb-api.abuse.ch/api/v1/";

#[derive(Debug, Deserialize)]
pub struct MalwareInformation {
    #[serde(rename = "sha256_hash", default)]
    pub sha256_hash: Option<String>,

    #[serde(rename = "sha3_384_hash", default)]
    pub sha384_hash: Option<String>,

    #[serde(rename = "sha1_hash", default)]
    pub sha1_hash: Option<String>,

    #[serde(rename = "md5_hash", default)]
    pub md5_hash: Option<String>,

    #[serde(rename = "first_seen", default)]
    pub first_seen: Option<String>,

    #[serde(rename = "last_seen", default)]
    pub last_seen: Option<String>,

    #[serde(rename = "file_name", default)]
    pub file_name: Option<String>,

    #[serde(rename = "file_size", default)]
    pub file_size: i64,

    #[serde(rename = "file_type_mime", default)]
    pub file_type_mime: Option<String>,

    #[serde(rename = "file_type", default)]
    pub file_type: Option<String>,

    #[serde(rename = "reporter", default)]
    pub reporter: Option<String>,

    #[serde(rename = "origin_country", default)]
    pub origin_country: Option<serde_json::Value>,

    #[serde(rename = "anonymous", default)]
    pub anonymous: i64,

    #[serde(rename = "signature", default)]
    pub signature: Option<String>,

    #[serde(rename = "imphash", default)]
    pub imphash: Option<String>,

    #[serde(rename = "tlsh", default)]
    pub tlsh: Option<String>,

    #[serde(rename = "telfhash", default)]
    pub telfhash: Option<String>,

    #[serde(rename = "gimphash", default)]
    pub gimphash: Option<String>,

    #[serde(rename = "ssdeep", default)]
    pub ssdeep: Option<String>,

    #[serde(rename = "dhash_icon", default)]
    pub dhash_icon: Option<String>,

    #[serde(rename = "comment", default)]
    pub comment: Option<String>,

    #[serde(rename = "archive_pw", default)]
    pub archive_pw: Option<serde_json::Value>,

    #[serde(rename = "tags", default)]
    pub tags: Option<Vec<String>>,

    #[serde(rename = "code_sign", default)]
    pub code_sign: Option<serde_json::Value>,

    #[serde(rename = "delivery_method", default)]
    pub delivery_method: Option<String>,

    #[serde(rename = "intelligence", default)]
    pub intelligence: Option<Intelligence>,

    #[serde(rename = "file_information", default)]
    pub file_information: Vec<FileInformation>,

    #[serde(rename = "ole_information", default)]
    pub ole_information: Vec<Option<serde_json::Value>>,

    #[serde(rename = "yara_rules", default)]
    pub yara_rules: Option<serde_json::Value>,

    #[serde(rename = "vendor_intel", default)]
    pub vendor_intel: Option<VendorIntel>,

    #[serde(rename = "comments", default)]
    pub comments: Option<serde_json::Value>,
}

#[derive(Debug, Default, Deserialize)]
pub struct FileInformation {
    #[serde(rename = "context", default)]
    pub context: Option<String>,

    #[serde(rename = "value", default)]
    pub value: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Intelligence {
    #[serde(rename = "clamav", default)]
    pub clamav: Option<Vec<String>>,

    #[serde(rename = "downloads", default)]
    pub downloads: Option<String>,

    #[serde(rename = "uploads", default)]
    pub uploads: Option<String>,

    #[serde(rename = "mail", default)]
    pub mail: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct VendorIntel {
    #[serde(rename = "CERT-PL_MWDB")]
    pub cert_pl_mwdb: Option<Cape>,

    #[serde(rename = "YOROI_YOMI")]
    pub yoroi_yomi: Option<YoroiYomi>,

    #[serde(rename = "vxCube")]
    pub vx_cube: Option<VxCube>,

    #[serde(rename = "CAPE")]
    pub cape: Option<Cape>,

    #[serde(rename = "Triage")]
    pub triage: Option<Triage>,

    #[serde(rename = "ReversingLabs")]
    pub reversing_labs: Option<ReversingLabs>,

    #[serde(rename = "Spamhaus_HBL")]
    pub spamhaus_hbl: Option<Vec<Cape>>,

    #[serde(rename = "UnpacMe")]
    pub unpac_me: Option<Vec<UnpacMe>>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Cape {
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    #[serde(rename = "link")]
    pub link: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct ReversingLabs {
    #[serde(rename = "threat_name")]
    pub threat_name: Option<String>,

    #[serde(rename = "status")]
    pub status: Option<String>,

    #[serde(rename = "first_seen")]
    pub first_seen: Option<String>,

    #[serde(rename = "scanner_count")]
    pub scanner_count: Option<String>,

    #[serde(rename = "scanner_match")]
    pub scanner_match: Option<String>,

    #[serde(rename = "scanner_percent")]
    pub scanner_percent: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Triage {
    #[serde(rename = "malware_family")]
    pub malware_family: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,

    #[serde(rename = "link")]
    pub link: Option<String>,

    #[serde(rename = "tags")]
    pub tags: Option<Vec<String>>,

    #[serde(rename = "signatures")]
    pub signatures: Option<Vec<Signature>>,

    #[serde(rename = "malware_config")]
    pub malware_config: Option<Vec<MalwareConfig>>,
}

#[derive(Debug, Default, Deserialize)]
pub struct MalwareConfig {
    #[serde(rename = "extraction")]
    pub extraction: Option<String>,

    #[serde(rename = "family")]
    pub family: Option<String>,

    #[serde(rename = "c2")]
    pub c2: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Signature {
    #[serde(rename = "signature")]
    pub signature: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct UnpacMe {
    #[serde(rename = "sha256_hash")]
    pub sha256_hash: Option<String>,

    #[serde(rename = "md5_hash")]
    pub md5_hash: Option<String>,

    #[serde(rename = "sha1_hash")]
    pub sha1_hash: Option<String>,

    #[serde(rename = "detections")]
    pub detections: Option<Vec<String>>,

    #[serde(rename = "link")]
    pub link: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct VxCube {
    #[serde(rename = "verdict")]
    pub verdict: Option<String>,

    #[serde(rename = "maliciousness")]
    pub maliciousness: Option<String>,

    #[serde(rename = "behaviour")]
    pub behaviour: Option<Vec<Behaviour>>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Behaviour {
    #[serde(rename = "threat_level")]
    pub threat_level: Option<ThreatLevel>,

    #[serde(rename = "rule")]
    pub rule: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct YoroiYomi {
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,
}

#[derive(Debug, Deserialize)]
pub enum ThreatLevel {
    #[serde(rename = "neutral")]
    Neutral,

    #[serde(rename = "suspicious")]
    Suspicious,
}

pub enum QueryLimit {
    Default,
    Limit(i32),
}

impl TryInto<i32> for QueryLimit {
    type Error = error::Error;

    fn try_into(self) -> Result<i32, Self::Error> {
        match self {
            Self::Limit(limit) if limit > 1000 => Err(error::Error::InvalidValue(format!(
                "Limit should be less than 1000. Specified limit {}",
                limit
            ))),
            Self::Limit(limit) => Ok(limit),
            Self::Default => Ok(50),
        }
    }
}

pub enum RecentAdditionsSelector {
    Time,
    Latest(i32),
}

impl From<RecentAdditionsSelector> for String {
    fn from(value: RecentAdditionsSelector) -> Self {
        match value {
            RecentAdditionsSelector::Time => String::from("time"),
            RecentAdditionsSelector::Latest(latest) => latest.to_string(),
        }
    }
}

struct QueryParams<'a> {
    operation: &'a str,
    key: Option<&'a str>,
    value: Option<String>,
    limit: Option<QueryLimit>,
}

impl<'a> TryInto<std::collections::HashMap<&'a str, String>> for QueryParams<'a> {
    type Error = error::Error;

    fn try_into(self) -> Result<std::collections::HashMap<&'a str, String>, Self::Error> {
        let mut query_params =
            std::collections::HashMap::from([("query", self.operation.to_string())]);

        if let (Some(query_key), Some(query_value)) = (self.key, self.value) {
            query_params.insert(query_key, query_value);
        }

        if let Some(limit) = self.limit {
            query_params.insert(
                "limit",
                <QueryLimit as TryInto<i32>>::try_into(limit)?.to_string(),
            );
        }

        Ok(query_params)
    }
}

pub enum QueryOperation {
    Hash(String),
    CertIssuerCN(String),
    CertSubjectCN(String),
    CertSerialNumber(String),
    RecentAdditions(RecentAdditionsSelector),
    Tag(String, QueryLimit),
    Signature(String, QueryLimit),
    FileType(String, QueryLimit),
    ClamavSignature(String, QueryLimit),
    Imphash(String, QueryLimit),
    TLSH(String, QueryLimit),
    Telfhash(String, QueryLimit),
    Gimphash(String, QueryLimit),
    IconDhash(String, QueryLimit),
    YaraInfo(String, QueryLimit),
}

impl TryInto<std::collections::HashMap<&str, String>> for QueryOperation {
    type Error = error::Error;

    fn try_into(self) -> Result<std::collections::HashMap<&'static str, String>, Self::Error> {
        let query_params = match self {
            Self::Tag(query_value, limit) => QueryParams {
                operation: "get_taginfo",
                key: Some("tag"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Signature(query_value, limit) => QueryParams {
                operation: "get_siginfo",
                key: Some("signature"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::FileType(query_value, limit) => QueryParams {
                operation: "get_file_type",
                key: Some("file_type"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::ClamavSignature(query_value, limit) => QueryParams {
                operation: "get_clamavinfo",
                key: Some("clamav"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Imphash(query_value, limit) => QueryParams {
                operation: "get_imphash",
                key: Some("imphash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::TLSH(query_value, limit) => QueryParams {
                operation: "get_tlsh",
                key: Some("tlsh"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Telfhash(query_value, limit) => QueryParams {
                operation: "get_telfhash",
                key: Some("telfhash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Gimphash(query_value, limit) => QueryParams {
                operation: "get_gimphash",
                key: Some("gimphash"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::IconDhash(query_value, limit) => QueryParams {
                operation: "get_dhash_icon",
                key: Some("dhash_icon"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::YaraInfo(query_value, limit) => QueryParams {
                operation: "get_yarainfo",
                key: Some("yara_rule"),
                value: Some(query_value),
                limit: Some(limit),
            },
            Self::Hash(hash) => QueryParams {
                operation: "get_info",
                key: Some("hash"),
                value: Some(hash),
                limit: None,
            },
            Self::CertIssuerCN(issuer_cn) => QueryParams {
                operation: "get_issuerinfo",
                key: Some("issuer_cn"),
                value: Some(issuer_cn),
                limit: None,
            },
            Self::CertSubjectCN(subject_cn) => QueryParams {
                operation: "get_subjectinfo",
                key: Some("subject_cn"),
                value: Some(subject_cn),
                limit: None,
            },
            Self::CertSerialNumber(serial_number) => QueryParams {
                operation: "get_certificate",
                key: Some("serial_number"),
                value: Some(serial_number),
                limit: None,
            },
            Self::RecentAdditions(recent_addition) => QueryParams {
                operation: "get_recent",
                key: Some("selector"),
                value: Some(recent_addition.into()),
                limit: None,
            },
        };

        query_params.try_into()
    }
}

#[derive(Debug, Deserialize)]
pub struct CertBlocklist {
    #[serde(rename = "time_stamp")]
    pub time_stamp: String,

    #[serde(rename = "serial_number")]
    pub serial_number: String,

    #[serde(rename = "thumbprint")]
    pub thumbprint: String,

    #[serde(rename = "thumbprint_algorithm")]
    pub thumbprint_algorithm: String,

    #[serde(rename = "subject_cn")]
    pub subject_cn: String,

    #[serde(rename = "issuer_cn")]
    pub issuer_cn: String,

    #[serde(rename = "valid_from")]
    pub valid_from: String,

    #[serde(rename = "valid_to")]
    pub valid_to: String,

    #[serde(rename = "cscb_listed")]
    pub cscb_listed: bool,

    #[serde(rename = "cscb_reason")]
    pub cscb_reason: String,
}

#[derive(Debug, Deserialize)]
pub struct QueryResponse<T> {
    #[serde(rename = "query_status")]
    query_status: String,

    #[serde(rename = "data")]
    data: Option<Vec<T>>,
}

pub fn query_malware_samples(
    web_client: &impl WebFetch,
    query_op: QueryOperation,
) -> QueryResult<Vec<MalwareInformation>> {
    let response = web_client.fetch(MALWARE_BAZAAR_API, query_op.try_into()?)?;
    let response: QueryResponse<MalwareInformation> = serde_json::from_str(&response)?;

    if let Some(response) = response.data {
        Ok(response)
    } else {
        Err(error::Error::QueryError(response.query_status))
    }
}

pub fn query_code_signing_block_list(
    web_client: &impl WebFetch,
) -> QueryResult<Vec<CertBlocklist>> {
    let response = web_client.fetch(
        MALWARE_BAZAAR_API,
        std::collections::HashMap::from([("query", String::from("get_cscb"))]),
    )?;
    let response: QueryResponse<CertBlocklist> = serde_json::from_str(&response)?;

    if let Some(response) = response.data {
        Ok(response)
    } else {
        Err(error::Error::QueryError(response.query_status))
    }
}

#[cfg(test)]
mod tests {

    use crate::fakers::FakeHttpReqwest;

    use super::*;

    const ILLEGAL_HASH_JSON: &str = "{
        \"query_status\": \"illegal_hash\"
    }";

    const HASH_NOT_FOUND_JSON: &str = "{
        \"query_status\": \"hash_not_found\"
    }";

    const NO_HASH_PROVIDED_JSON: &str = "{
        \"query_status\": \"no_hash_provided\"
    }";

    #[test]
    fn test_query_results() {
        let fake_client = FakeHttpReqwest::default()
            .set_success_response(include_str!("test_files/malware_sample_resp.json").to_string());

        let query_results = query_malware_samples(
            &fake_client,
            QueryOperation::Tag(String::from("deadbeef"), QueryLimit::Default),
        );

        assert!(
            !query_results.unwrap().is_empty(),
            "Malware information cannot be empty"
        );

        let fake_client = fake_client
            .set_success_response(include_str!("test_files/cscb_response.json").to_string());

        let query_results = query_code_signing_block_list(&fake_client);

        assert!(
            !query_results.unwrap().is_empty(),
            "Malware Bazaar certificate list cannot be empty"
        );
    }

    #[test]
    fn test_return_error_when_hash_is_not_valid() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(ILLEGAL_HASH_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_no_hash_was_provided() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(NO_HASH_PROVIDED_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_hash_was_not_found() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(HASH_NOT_FOUND_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_on_request_error() {
        let fake_client = FakeHttpReqwest::default()
            .set_error_response(error::Error::Request(String::from("Request error")));
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::Request(_)));
    }

    #[test]
    fn test_return_error_on_limit_greater_than_1000() {
        let fake_client = FakeHttpReqwest::default();

        let result = query_malware_samples(
            &fake_client,
            QueryOperation::FileType(String::from("deadbeef"), QueryLimit::Limit(1001)),
        )
        .unwrap_err();

        assert!(matches!(result, error::Error::InvalidValue(_)))
    }
}
