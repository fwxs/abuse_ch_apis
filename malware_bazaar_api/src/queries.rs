extern crate serde_json;

use crate::{error, WebFetch};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct MalwareInformation {
    #[serde(rename = "sha256_hash", default)]
    pub sha256_hash: Option<String>,

    #[serde(rename = "sha3_384_hash", default)]
    pub sha384_hash: Option<String>,

    #[serde(rename = "sha1_hash", default)]
    pub sha1_hash: Option<String>,

    #[serde(rename = "md5_hash", default)]
    pub md5_hash: Option<String>,

    #[serde(rename = "first_seen", default)]
    pub first_seen: Option<String>,

    #[serde(rename = "last_seen", default)]
    pub last_seen: Option<String>,

    #[serde(rename = "file_name", default)]
    pub file_name: Option<String>,

    #[serde(rename = "file_size", default)]
    pub file_size: i64,

    #[serde(rename = "file_type_mime", default)]
    pub file_type_mime: Option<String>,

    #[serde(rename = "file_type", default)]
    pub file_type: Option<String>,

    #[serde(rename = "reporter", default)]
    pub reporter: Option<String>,

    #[serde(rename = "origin_country", default)]
    pub origin_country: Option<serde_json::Value>,

    #[serde(rename = "anonymous", default)]
    pub anonymous: i64,

    #[serde(rename = "signature", default)]
    pub signature: Option<String>,

    #[serde(rename = "imphash", default)]
    pub imphash: Option<String>,

    #[serde(rename = "tlsh", default)]
    pub tlsh: Option<String>,

    #[serde(rename = "telfhash", default)]
    pub telfhash: Option<String>,

    #[serde(rename = "gimphash", default)]
    pub gimphash: Option<String>,

    #[serde(rename = "ssdeep", default)]
    pub ssdeep: Option<String>,

    #[serde(rename = "dhash_icon", default)]
    pub dhash_icon: Option<String>,

    #[serde(rename = "comment", default)]
    pub comment: Option<String>,

    #[serde(rename = "archive_pw", default)]
    pub archive_pw: Option<serde_json::Value>,

    #[serde(rename = "tags", default)]
    pub tags: Vec<String>,

    #[serde(rename = "code_sign", default)]
    pub code_sign: Option<serde_json::Value>,

    #[serde(rename = "delivery_method", default)]
    pub delivery_method: Option<String>,

    #[serde(rename = "intelligence", default)]
    pub intelligence: Intelligence,

    #[serde(rename = "file_information", default)]
    pub file_information: Vec<FileInformation>,

    #[serde(rename = "ole_information", default)]
    pub ole_information: Vec<Option<serde_json::Value>>,

    #[serde(rename = "yara_rules", default)]
    pub yara_rules: Option<serde_json::Value>,

    #[serde(rename = "vendor_intel", default)]
    pub vendor_intel: VendorIntel,

    #[serde(rename = "comments", default)]
    pub comments: Option<serde_json::Value>,
}

#[derive(Debug, Default, Deserialize)]
pub struct FileInformation {
    #[serde(rename = "context", default)]
    pub context: Option<String>,

    #[serde(rename = "value", default)]
    pub value: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Intelligence {
    #[serde(rename = "clamav", default)]
    pub clamav: Option<Vec<String>>,

    #[serde(rename = "downloads", default)]
    pub downloads: Option<String>,

    #[serde(rename = "uploads", default)]
    pub uploads: Option<String>,

    #[serde(rename = "mail", default)]
    pub mail: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct VendorIntel {
    #[serde(rename = "CERT-PL_MWDB")]
    pub cert_pl_mwdb: Cape,

    #[serde(rename = "YOROI_YOMI")]
    pub yoroi_yomi: YoroiYomi,

    #[serde(rename = "vxCube")]
    pub vx_cube: VxCube,

    #[serde(rename = "CAPE")]
    pub cape: Cape,

    #[serde(rename = "Triage")]
    pub triage: Triage,

    #[serde(rename = "ReversingLabs")]
    pub reversing_labs: ReversingLabs,

    #[serde(rename = "Spamhaus_HBL")]
    pub spamhaus_hbl: Vec<Cape>,

    #[serde(rename = "UnpacMe")]
    pub unpac_me: Vec<UnpacMe>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Cape {
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    #[serde(rename = "link")]
    pub link: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct ReversingLabs {
    #[serde(rename = "threat_name")]
    pub threat_name: Option<String>,

    #[serde(rename = "status")]
    pub status: Option<String>,

    #[serde(rename = "first_seen")]
    pub first_seen: Option<String>,

    #[serde(rename = "scanner_count")]
    pub scanner_count: Option<String>,

    #[serde(rename = "scanner_match")]
    pub scanner_match: Option<String>,

    #[serde(rename = "scanner_percent")]
    pub scanner_percent: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Triage {
    #[serde(rename = "malware_family")]
    pub malware_family: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,

    #[serde(rename = "link")]
    pub link: Option<String>,

    #[serde(rename = "tags")]
    pub tags: Option<Vec<String>>,

    #[serde(rename = "signatures")]
    pub signatures: Option<Vec<Signature>>,

    #[serde(rename = "malware_config")]
    pub malware_config: Option<Vec<MalwareConfig>>,
}

#[derive(Debug, Default, Deserialize)]
pub struct MalwareConfig {
    #[serde(rename = "extraction")]
    pub extraction: Option<String>,

    #[serde(rename = "family")]
    pub family: Option<String>,

    #[serde(rename = "c2")]
    pub c2: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Signature {
    #[serde(rename = "signature")]
    pub signature: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct UnpacMe {
    #[serde(rename = "sha256_hash")]
    pub sha256_hash: Option<String>,

    #[serde(rename = "md5_hash")]
    pub md5_hash: Option<String>,

    #[serde(rename = "sha1_hash")]
    pub sha1_hash: Option<String>,

    #[serde(rename = "detections")]
    pub detections: Option<Vec<String>>,

    #[serde(rename = "link")]
    pub link: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct VxCube {
    #[serde(rename = "verdict")]
    pub verdict: Option<String>,

    #[serde(rename = "maliciousness")]
    pub maliciousness: Option<String>,

    #[serde(rename = "behaviour")]
    pub behaviour: Option<Vec<Behaviour>>,
}

#[derive(Debug, Default, Deserialize)]
pub struct Behaviour {
    #[serde(rename = "threat_level")]
    pub threat_level: Option<ThreatLevel>,

    #[serde(rename = "rule")]
    pub rule: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
pub struct YoroiYomi {
    #[serde(rename = "detection")]
    pub detection: Option<String>,

    #[serde(rename = "score")]
    pub score: Option<String>,
}

#[derive(Debug, Deserialize)]
pub enum ThreatLevel {
    #[serde(rename = "neutral")]
    Neutral,

    #[serde(rename = "suspicious")]
    Suspicious,
}

pub enum QueryLimit {
    Default,
    Limit(i32),
    Skip,
}

impl QueryLimit {
    fn value(self) -> Result<Option<i32>, error::Error> {
        match self {
            Self::Limit(limit) => {
                if limit < 1000 {
                    Ok(Some(limit))
                } else {
                    Err(error::Error::InvalidValue(format!(
                        "Limit should be less than 1000. Specified limit {}",
                        limit
                    )))
                }
            }
            Self::Default => Ok(Some(50)),
            Self::Skip => Ok(None),
        }
    }
}

pub enum QueryOperation {
    Hash(String),
    CertIssuerCN(String),
    CertSubjectCN(String),
    CertSerialNumber(String),
    Tag(String, QueryLimit),
    Signature(String, QueryLimit),
    FileType(String, QueryLimit),
    ClamavSignature(String, QueryLimit),
    Imphash(String, QueryLimit),
    TLSH(String, QueryLimit),
    Telfhash(String, QueryLimit),
    Gimphash(String, QueryLimit),
    IconDhash(String, QueryLimit),
    YaraInfo(String, QueryLimit),
}

impl TryInto<std::collections::HashMap<&str, String>> for QueryOperation {
    type Error = error::Error;

    fn try_into(self) -> Result<std::collections::HashMap<&'static str, String>, Self::Error> {
        let (query_op, query_key, query_value, limit): (&str, &str, String, QueryLimit) = match self
        {
            Self::Tag(query_value, limit) => ("get_taginfo", "tag", query_value, limit),
            Self::Signature(query_value, limit) => ("get_siginfo", "signature", query_value, limit),
            Self::FileType(query_value, limit) => {
                ("get_file_type", "file_type", query_value, limit)
            }
            Self::ClamavSignature(query_value, limit) => {
                ("get_clamavinfo", "clamav", query_value, limit)
            }
            Self::Imphash(query_value, limit) => ("get_imphash", "imphash", query_value, limit),
            Self::TLSH(query_value, limit) => ("get_tlsh", "tlsh", query_value, limit),
            Self::Telfhash(query_value, limit) => ("get_telfhash", "telfhash", query_value, limit),
            Self::Gimphash(query_value, limit) => ("get_gimphash", "gimphash", query_value, limit),
            Self::IconDhash(query_value, limit) => {
                ("get_dhash_icon", "dhash_icon", query_value, limit)
            }
            Self::YaraInfo(query_value, limit) => ("get_yarainfo", "yara_rule", query_value, limit),
            Self::Hash(hash) => ("get_info", "hash", hash, QueryLimit::Skip),
            Self::CertIssuerCN(issuer_cn) => {
                ("get_issuerinfo", "issuer_cn", issuer_cn, QueryLimit::Skip)
            }
            Self::CertSubjectCN(subject_cn) => (
                "get_subjectinfo",
                "subject_cn",
                subject_cn,
                QueryLimit::Skip,
            ),
            Self::CertSerialNumber(serial_number) => (
                "get_certificate",
                "serial_number",
                serial_number,
                QueryLimit::Skip,
            ),
        };

        let mut query_params = std::collections::HashMap::from([
            ("query", query_op.to_string()),
            (query_key, query_value),
        ]);

        if let Some(limit) = limit.value()? {
            query_params.insert("limit", limit.to_string());
        }

        Ok(query_params)
    }
}

pub type QueryResult<T> = Result<T, error::Error>;

const MALWARE_BAZAAR_API: &str = "https://mb-api.abuse.ch/api/v1/";

#[derive(Debug, Deserialize)]
pub struct QueryResponse<T> {
    #[serde(rename = "query_status")]
    query_status: String,

    #[serde(rename = "data")]
    data: Option<Vec<T>>,
}

pub fn query_malware_samples(
    web_client: &impl WebFetch,
    query_op: QueryOperation,
) -> QueryResult<Vec<MalwareInformation>> {
    let response = web_client.fetch(MALWARE_BAZAAR_API, query_op.try_into()?)?;
    let response: QueryResponse<MalwareInformation> = serde_json::from_str(&response)?;

    if let Some(response) = response.data {
        Ok(response)
    } else {
        Err(error::Error::QueryError(response.query_status))
    }
}

#[cfg(test)]
mod tests {

    use crate::fakers::FakeHttpReqwest;

    use super::*;

    const ILLEGAL_HASH_JSON: &str = "{
        \"query_status\": \"illegal_hash\"
    }";

    const HASH_NOT_FOUND_JSON: &str = "{
        \"query_status\": \"hash_not_found\"
    }";

    const NO_HASH_PROVIDED_JSON: &str = "{
        \"query_status\": \"no_hash_provided\"
    }";

    #[test]
    fn test_query_results() {
        let fake_client = FakeHttpReqwest::default()
            .set_success_response(include_str!("test_files/malware_sample_resp.json").to_string());

        let query_results = vec![query_malware_samples(
            &fake_client,
            QueryOperation::Tag(String::from("deadbeef"), QueryLimit::Default),
        )];

        for result in query_results {
            assert!(
                !result.unwrap().is_empty(),
                "Malware information cannot be empty"
            );
        }
    }

    #[test]
    fn test_return_error_when_hash_is_not_valid() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(ILLEGAL_HASH_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_no_hash_was_provided() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(NO_HASH_PROVIDED_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_when_hash_was_not_found() {
        let fake_client =
            FakeHttpReqwest::default().set_success_response(HASH_NOT_FOUND_JSON.to_string());
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::QueryError(_)));
    }

    #[test]
    fn test_return_error_on_request_error() {
        let fake_client = FakeHttpReqwest::default()
            .set_error_response(error::Error::Request(String::from("Request error")));
        let result =
            query_malware_samples(&fake_client, QueryOperation::Hash(String::from("deadbeef")))
                .unwrap_err();

        assert!(matches!(result, error::Error::Request(_)));
    }
}
